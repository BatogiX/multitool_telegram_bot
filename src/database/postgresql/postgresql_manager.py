import logging

import asyncpg
from asyncpg import Pool, Connection, Record

from database.base import AbstractRelationDatabase
from models.db_record.password_record import EncryptedRecord


class PostgresqlManager(AbstractRelationDatabase):
    """
    Implementation of a relational database manager for PostgreSQL.
    """
    _pool: Pool | None = None

    async def connect(self) -> Pool:
        """
        Connect to PostgreSQL using DSN if available, otherwise using individual parameters.
        """
        if self._pool is None:
            self._pool = await asyncpg.create_pool(
                dsn=self._c.url,
                min_size=self._c.min_pool_size,
                max_size=self._c.max_pool_size,
                max_queries=self._c.max_queries
            ) if self._c.url else await asyncpg.create_pool(
                host=self._c.host,
                port=self._c.port,
                user=self._c.user,
                password=self._c.password,
                database=self._c.name,
                min_size=self._c.min_pool_size,
                max_size=self._c.max_pool_size,
                max_queries=self._c.max_queries
            )
            logging.info(f"Connected to PostgreSQL via {'URL' if self._c.url else 'host/port'}")
        return self._pool

    async def disconnect(self) -> None:
        if self._pool:
            await self._pool.close()
            logging.info("Disconnected from PostgreSQL")
            self._pool = None

    async def _execute(self, query: str, *args) -> None:
        async with self._pool.acquire() as conn:
            conn: Connection
            await conn.execute(query, *args)

    async def _fetch_row(self, query: str, *args) -> Record | None:
        async with self._pool.acquire() as conn:
            conn: Connection
            return await conn.fetchrow(query, *args)

    async def _fetch_value(self, query: str, *args) -> any:
        async with self._pool.acquire() as conn:
            conn: Connection
            return await conn.fetchval(query, *args)

    async def _fetch_all(self, query: str, *args) -> list[Record | None]:
        async with self._pool.acquire() as conn:
            conn: Connection
            return await conn.fetch(query, *args)

    async def init_db(self) -> None:
        await self._execute(
            '''
            CREATE TABLE IF NOT EXISTS public.users
            (
                user_id bigint NOT NULL PRIMARY KEY,
                user_name text,
                created_at TIMESTAMP NOT NULL DEFAULT now(),
                full_name text NOT NULL,
                salt bytea NOT NULL
            )
            '''
        )

        await self._execute(
            '''
            CREATE TABLE IF NOT EXISTS public.passwords
            (
                password_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                user_id BIGINT NOT NULL,
                service TEXT NOT NULL,
                iv BYTEA NOT NULL,
                tag BYTEA NOT NULL,
                ciphertext BYTEA NOT NULL,
                CONSTRAINT passwords_users_user_id_fk FOREIGN KEY (user_id) REFERENCES public.users (user_id) ON DELETE CASCADE
            );

            CREATE INDEX IF NOT EXISTS idx_passwords_user_id_service ON public.passwords (user_id, service)
            '''
        )

    async def create_user_if_not_exists(self, user_id: int, user_name: str, full_name: str, salt: bytes) -> None:
        await self._execute(
            """
            INSERT INTO public.users (user_id, user_name, full_name, salt)
            VALUES ($1, $2, $3, $4)
            ON CONFLICT (user_id) DO NOTHING
            """,
            user_id, user_name, full_name, salt
        )

    async def get_services(self, user_id: int, offset: int, limit: int) -> list[str]:
        records: list[Record] = await self._fetch_all(
            "SELECT DISTINCT service FROM public.passwords WHERE user_id = $1 ORDER BY service OFFSET $2 LIMIT $3",
            user_id, offset, limit + 1
        )
        return [record.get("service") for record in records]

    async def get_salt(self, user_id: int) -> bytes:
        return await self._fetch_value(
            "SELECT salt FROM public.users WHERE user_id = $1",
            user_id
        )

    async def create_password(self, user_id: int, service: str, iv: bytes, tag: bytes, ciphertext: bytes) -> None:
        await self._execute(
            "INSERT INTO public.passwords (user_id, service, iv, tag, ciphertext) VALUES ($1, $2, $3, $4, $5)",
            user_id, service, iv, tag, ciphertext
        )

    async def get_passwords(self, user_id: int, service: str, offset: int, limit: int) -> list[EncryptedRecord]:
        records: list[Record] = await self._fetch_all(
            "SELECT service, iv, tag, ciphertext FROM public.passwords WHERE user_id = $1 AND service = $2 OFFSET $3 LIMIT $4",
            user_id, service, offset, limit + 1
        )
        return [EncryptedRecord(
            service=record.get("service"),
            iv=record.get("iv"),
            tag=record.get('tag'),
            ciphertext=record.get('ciphertext')
        ) for record in records]

    async def get_rand_password(self, user_id: int) -> EncryptedRecord | None:
        record: Record = await self._fetch_row(
            "SELECT service, iv, tag, ciphertext FROM public.passwords WHERE user_id = $1",
            user_id
        )
        return EncryptedRecord(
            service=record.get("service"),
            iv=record.get("iv"),
            tag=record.get('tag'),
            ciphertext=record.get('ciphertext')
        ) if record else None

    async def change_service(self, new_service: str, user_id: int, old_service: str) -> None:
        await self._execute(
            "UPDATE public.passwords SET service = $1 WHERE user_id = $2 AND service = $3",
            new_service, user_id, old_service
        )

    async def delete_services(self, user_id: int) -> None:
        await self._execute(
            "DELETE FROM public.passwords WHERE user_id = $1",
            user_id
        )

    async def delete_service(self, user_id: int, service: str) -> None:
        await self._execute(
            "DELETE FROM public.passwords WHERE user_id = $1 AND service = $2",
            user_id, service
        )

    async def delete_password(self, user_id: int, service: str, ciphertext: bytes) -> None:
        await self._execute(
            "DELETE FROM public.passwords WHERE user_id = $1 AND service = $2 AND ciphertext = $3",
            user_id, service, ciphertext
        )

    async def import_passwords(self, user_id: int, encrypted_records: list[EncryptedRecord]) -> None:
        values = [
            (user_id, r.service, r.iv, r.tag, r.ciphertext)
            for r in encrypted_records
        ]

        query = """
        INSERT INTO public.passwords (user_id, service, iv, tag, ciphertext)
        SELECT * FROM unnest($1::int[], $2::text[], $3::bytea[], $4::bytea[], $5::bytea[])
        """

        await self._execute(
            query,
            [v[0] for v in values],  # user_id
            [v[1] for v in values],        # service
            [v[2] for v in values],        # iv
            [v[3] for v in values],        # tag
            [v[4] for v in values]         # ciphertext
        )

    async def export_passwords(self, user_id: int) -> list[EncryptedRecord] | None:
        records = await self._fetch_all(
            "SELECT service, iv, tag, ciphertext FROM public.passwords WHERE user_id = $1",
            user_id
        )
        return [EncryptedRecord(
                service=record.get("service"),
                iv=record.get("iv"),
                tag=record.get("tag"),
                ciphertext=record.get("ciphertext")
        ) for record in records]

    async def inline_search_service(self, user_id: int, service: str, limit: int) -> list[str]:
        records = await self._fetch_all(
            "SELECT DISTINCT service FROM public.passwords WHERE user_id = $1 AND service LIKE $2 LIMIT $3",
            user_id, f"%{service}%", limit
        )
        return [record.get("service") for record in records]